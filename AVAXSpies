//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0; // Restrict to single version 0.8.8 

import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
// import for Strings Library is Missing

interface IIERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    function burn(uint tokenId) external;
}

contract AVAXSpies is ERC721, Ownable { // Import Pausable as well 
    using Strings for uint256; // Strings library is missing
    uint256 public mintPrice = 1 ether;
    uint256 public maxSupply;
    uint256 public totalSupply; // recommended to have totalSupply as constant or immutable
    bool public isMintEnabled;
    uint public constant max_mint_per_tx = 10;
    mapping(address => uint256) public mintedWallets;

    string public baseUri;
    string public baseExtension = ".json";
    IIERC721 public stik;

    constructor(address _stik_address) payable ERC721('AVAX Spies', 'SPIES'){
        maxSupply = 1000; // Either total supply should come as input or declare it as constant 
        // Base IPFS URI of the NFT metadata
        baseUri = "ipfs://xxxxxxxxxxxxxxxxxxxxxxxxx/"; // Either url should come as input or declare it as constant 
        totalSupply = 0; // Either total supply should come as input or declare it as constant 
        stik = IIERC721(_stik_address);
    }
    
    // Public Functions
    function mint(uint[] memory tokenIds) external payable {
        require(isMintEnabled, 'minting not enabled');
        require(tokenIds.length <= max_mint_per_tx, 'Maximum mint of 10 NFTs per transaction.');
        uint256 curTotalSupply = totalSupply;
        require(curTotalSupply + tokenIds.length <= maxSupply, 'Exceeds maxSupply');
        require(tokenIds.length * mintPrice <= msg.value, 'Insufficient funds. More AVAX needed!');

        for(uint i=0;i<tokenIds.length;i++){
            require(stik.ownerOf(tokenIds[i])==msg.sender,"Sender not owner");
            stik.burn(tokenIds[i]);
            mintedWallets[msg.sender]++;
            totalSupply++;
            uint256 tokenId = totalSupply; // delete this
            _safeMint(msg.sender, tokenId); // _safeMint(msg.sender, totalSupply);
        }
    }

    // Owner-only Functions
    function toggleIsMintEnabled() external onlyOwner {
        isMintEnabled = !isMintEnabled;
    }

    function setMaxSupply(uint256 _maxSupply) external onlyOwner {
        maxSupply = _maxSupply;
    }

    function setBaseUri(string memory _baseUri) external onlyOwner {
        baseUri = _baseUri;
    }

    function setPrice(uint256 _price) external onlyOwner {
        mintPrice = _price;
}

    function withdrawAll() external payable onlyOwner {
        uint256 balance = address(this).balance;
        uint256 balanceOne = balance * 100 / 100;
        ( bool transferOne, ) = payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4).call{value: balanceOne}("");
        require(transferOne, "Transfer failed.");
    }

    // Funtions internal
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
 
        string memory currentBaseURI = _baseURI();
        return bytes(currentBaseURI).length > 0
            ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))
            : "";
    }
 
    function _baseURI() internal view virtual override returns (string memory) {
        return baseUri;
    }

    function setSTIKContract(address _stik_address) public onlyOwner(){
        stik = IIERC721(_stik_address);
    }
}
